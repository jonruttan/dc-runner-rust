version: 1
name: spec_lang_stdlib_profile_v1
categories:
  core_control:
  - std.core.subject
  - var
  - if
  - let
  - fn
  - call
  boolean_predicate:
  - std.logic.and
  - std.logic.or
  - std.logic.not
  - std.logic.xor
  - std.collection.any
  - std.collection.all
  - std.collection.none
  - std.collection.is_empty
  equality_comparison:
  - std.logic.eq
  - std.logic.neq
  - std.logic.equals
  - std.logic.lt
  - std.logic.lte
  - std.logic.gt
  - std.logic.gte
  - std.logic.compare
  - std.logic.between
  numeric:
  - std.math.add
  - std.math.sub
  - std.math.mul
  - std.math.div
  - std.math.mod
  - std.math.pow
  - std.math.abs
  - std.math.negate
  - std.math.inc
  - std.math.dec
  - std.math.clamp
  - std.math.round
  - std.math.floor
  - std.math.ceil
  - std.math.min
  - std.math.max
  - std.math.sum
  type_predicates:
  - std.type.json_type
  - std.type.is_null
  - std.type.is_bool
  - std.type.is_boolean
  - std.type.is_number
  - std.type.is_integer
  - std.type.is_string
  - std.type.is_list
  - std.type.is_array
  - std.type.is_dict
  - std.type.is_object
  text_regex:
  - std.string.contains
  - std.string.starts_with
  - std.string.ends_with
  - std.string.trim
  - std.string.lower
  - std.string.upper
  - std.string.split
  - std.string.join
  - std.string.replace
  - std.string.pad_left
  - std.string.pad_right
  - std.string.regex_match
  - std.string.matches
  - std.string.matches_all
  sequence_collection:
  - std.collection.len
  - std.collection.count
  - std.collection.first
  - std.collection.rest
  - std.collection.last
  - std.collection.nth
  - std.collection.take
  - std.collection.drop
  - std.collection.slice
  - std.collection.append
  - std.collection.prepend
  - std.collection.concat
  - std.collection.reverse
  - std.collection.flatten
  - std.math.range
  - std.collection.repeat
  - std.collection.map
  - std.collection.filter
  - std.collection.reject
  - std.collection.find
  - std.collection.reduce
  - std.collection.partition
  - std.collection.group_by
  - std.collection.uniq_by
  - std.collection.distinct
  - std.collection.sort
  - std.collection.sort_by
  - std.collection.zip
  - std.collection.zip_with
  - std.object.pluck
  - std.collection.includes
  - std.collection.in
  - std.collection.contains_all
  - std.collection.contains_any
  object_map:
  - std.object.has_key
  - std.object.get
  - std.object.get_in
  - std.object.get_or
  - std.object.has_path
  - std.object.keys
  - std.object.values
  - std.object.entries
  - std.object.assoc
  - std.object.dissoc
  - std.object.merge
  - std.object.merge_deep
  - std.object.pick
  - std.object.omit
  - std.object.prop_eq
  - std.object.where
  - std.object.keys_exact
  - std.object.keys_include
  - std.object.keys_exclude
  set_algebra:
  - std.set.union
  - std.set.intersection
  - std.set.difference
  - std.set.symmetric_difference
  - std.set.is_subset
  - std.set.is_superset
  - std.set.set_equals
  json_utilities:
  - std.json.parse
  - std.json.stringify
  null_default:
  - std.null.coalesce
  - std.null.default_to
  functional_combinators:
  - std.fn.identity
  - std.fn.always
  - std.fn.compose
  - std.fn.pipe
  schema_shape:
  - std.schema.match
  - std.schema.errors
  fs_path:
  - ops.fs.path.normalize
  - ops.fs.path.join
  - ops.fs.path.split
  - ops.fs.path.dirname
  - ops.fs.path.basename
  - ops.fs.path.extname
  - ops.fs.path.stem
  - ops.fs.path.is_abs
  - ops.fs.path.has_ext
  - ops.fs.path.change_ext
  - ops.fs.path.relativize
  - ops.fs.path.common_prefix
  - ops.fs.path.parents
  - ops.fs.path.within
  - ops.fs.path.compare
  - ops.fs.path.sort
  fs_file:
  - ops.fs.file.exists
  - ops.fs.file.is_file
  - ops.fs.file.is_dir
  - ops.fs.file.size_bytes
  - ops.fs.file.path
  - ops.fs.file.name
  - ops.fs.file.parent
  - ops.fs.file.ext
  - ops.fs.file.get
  - ops.fs.walk
  - ops.fs.file.set
  - ops.fs.file.append
  - ops.fs.file.mkdir_p
  - ops.fs.file.remove
  fs_json:
  - ops.fs.json.parse
  - ops.fs.json.get
  - ops.fs.json.get_or
  - ops.fs.json.has_path
  - ops.fs.yaml.parse
  - ops.fs.yaml.stringify
  - ops.fs.yaml.get
  - ops.fs.yaml.get_or
  - ops.fs.yaml.has_path
  fs_glob:
  - ops.fs.glob.match
  - ops.fs.glob.filter
  - ops.fs.glob.any
  - ops.fs.glob.all
  os_process:
  - ops.os.exec
  - ops.os.exec_capture
  - ops.os.exec_capture_ex
  - ops.os.env_get
  - ops.os.env_has
  - ops.os.cwd
  - ops.os.pid
  - ops.os.sleep_ms
  - ops.os.exit_code
  terminal_io:
  - ops.terminal.prompt
  helper_ops:
  - ops.helper.call
  job_ops:
  - ops.job.dispatch
symbols:
  std.core.subject:
    category: core_control
    arity: 0
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.helper.call:
    category: helper_ops
    arity: 2
    pure: false
    deterministic: false
    error_class: runtime
    parity_required: false
  ops.job.dispatch:
    category: job_ops
    arity: null
    pure: false
    deterministic: false
    error_class: runtime
    parity_required: false
  var:
    category: core_control
    arity: null
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  if:
    category: core_control
    arity: null
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  let:
    category: core_control
    arity: null
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  fn:
    category: core_control
    arity: null
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  call:
    category: core_control
    arity: null
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.logic.and:
    category: boolean_predicate
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.logic.or:
    category: boolean_predicate
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.logic.not:
    category: boolean_predicate
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.logic.xor:
    category: boolean_predicate
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.any:
    category: boolean_predicate
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.all:
    category: boolean_predicate
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.none:
    category: boolean_predicate
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.is_empty:
    category: boolean_predicate
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.logic.eq:
    category: equality_comparison
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.logic.neq:
    category: equality_comparison
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.logic.equals:
    category: equality_comparison
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.logic.lt:
    category: equality_comparison
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.logic.lte:
    category: equality_comparison
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.logic.gt:
    category: equality_comparison
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.logic.gte:
    category: equality_comparison
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.logic.compare:
    category: equality_comparison
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.logic.between:
    category: equality_comparison
    arity: 3
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.math.add:
    category: numeric
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.math.sub:
    category: numeric
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.math.mul:
    category: numeric
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.math.div:
    category: numeric
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.math.mod:
    category: numeric
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.math.pow:
    category: numeric
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.math.abs:
    category: numeric
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.math.negate:
    category: numeric
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.math.inc:
    category: numeric
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.math.dec:
    category: numeric
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.math.clamp:
    category: numeric
    arity: 3
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.math.round:
    category: numeric
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.math.floor:
    category: numeric
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.math.ceil:
    category: numeric
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.math.min:
    category: numeric
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.math.max:
    category: numeric
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.math.sum:
    category: numeric
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.type.json_type:
    category: type_predicates
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.type.is_null:
    category: type_predicates
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.type.is_bool:
    category: type_predicates
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.type.is_boolean:
    category: type_predicates
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.type.is_number:
    category: type_predicates
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.type.is_integer:
    category: type_predicates
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.type.is_string:
    category: type_predicates
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.type.is_list:
    category: type_predicates
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.type.is_array:
    category: type_predicates
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.type.is_dict:
    category: type_predicates
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.type.is_object:
    category: type_predicates
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.string.contains:
    category: text_regex
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
    docs:
      - id: std.string.contains.doc.1.implementer
        summary: Check whether a text contains a substring with deterministic matching.
        audience: implementer
        status: active
        description: |-
          Purpose: Detect if the first argument contains the second argument.
          Inputs are consumed as plain strings before optional normalization in the runtime.
        inputs:
          - haystack: Input text to search.
          - needle: Substring expression to match.
        returns:
          - A boolean true when the needle is found, false otherwise.
        errors:
          - Schema failures when either input is not a string.
          - Runtime validation failures when arguments are missing.
        usage_context:
          - Use in assertions and predicates where deterministic text detection is required.
          - Normalize values before calling when comparing user-provided text.
        examples:
          - Evaluate `std.string.contains` with `"error: retry"` and `"retry"` to verify true.
          - Evaluate with `"warning"` and `"timeout"` to verify false.
      - id: std.string.contains.doc.1.operator
        summary: Use substring checks in operational run paths with deterministic outcomes.
        audience: operator
        status: active
        description: |-
          Purpose: Detect whether a token or phrase appears in an emitted log line or
          status payload before branching.
          Ensure all calls remain deterministic by keeping input normalization explicit.
        inputs:
          - haystack: text from logs, events, or status messages.
          - needle: deterministic search token.
        returns:
          - Boolean result used to route operational behavior.
        errors:
          - Validation failures for malformed non-string values.
          - Determinism drift when caller mutates inputs between evaluations.
        usage_context:
          - Route runbook logic, incident pattern matching, and status classification safely.
        examples:
          - Check for `"error"` in command output before deciding escalation.
      - id: std.string.contains.doc.1.integrator
        summary: Compose deterministic text-routing conditions for downstream integrations.
        audience: integrator
        status: active
        description: |-
          Purpose: Provide stable substring behavior for integration conditions and
          contract compositions.
        inputs:
          - haystack: text from upstream service or upstream assertion payload.
          - needle: normalized selector used by downstream steps.
        returns:
          - Boolean membership result.
        errors:
          - Schema validation for wrong argument shape and wrong arity.
          - Integration-time failures caused by locale/normalization mismatch.
        usage_context:
          - Use in policy-driven branching or payload transformation logic.
      - id: std.string.contains.doc.1.maintainer
        summary: Understand behavior and compatibility impact before upgrading consumers.
        audience: maintainer
        status: active
        description: |-
          Purpose: Confirm deterministic text containment semantics remain stable across
          profile or implementation changes.
        inputs:
          - haystack: canonical input text.
          - needle: query substring.
        returns:
          - Boolean true/false result and schema-shaped validation behavior.
        errors:
          - Failures from malformed invocation shape.
          - Changes in normalization behavior in implementation changes.
        usage_context:
          - Evaluate in change risk reviews and compatibility planning.
        examples:
          - Regression test with fixed input/output pair for version upgrades.
      - id: std.string.contains.doc.1.governance
        summary: Validate containment checks used for governance and control logic.
        audience: governance
        status: active
        description: |-
          Purpose: Ensure substring checks produce auditable, deterministic outcomes
          for compliance and policy checks.
        inputs:
          - haystack: governed source text.
          - needle: policy keyword.
        returns:
          - Boolean result suitable for deterministic gate decisions.
        errors:
          - Input validation failures and runtime assertion mismatches.
        usage_context:
          - Use for deterministic control assertions that must be explainable in audits.
      - id: std.string.contains.doc.1.reviewer
        summary: Confirm API behavior and failure handling are complete and deterministic.
        audience: reviewer
        status: active
        description: |-
          Purpose: Provide reviewer-ready semantics for substring checks and edge cases.
        inputs:
          - haystack: review subject string.
          - needle: token to search.
        returns:
          - Boolean match status.
        errors:
          - Type and argument-shape validation failures.
          - Invalid usage where search token is empty.
        usage_context:
          - Review test cases and spec-driven behavior assertions.
      - id: std.string.contains.doc.1.auditor
        summary: Produce evidence-ready behavior for substring assertions and controls.
        audience: auditor
        status: active
        description: |-
          Purpose: Record deterministic behavior and validation boundaries for auditability.
        inputs:
          - haystack: text string under review.
          - needle: searched token.
        returns:
          - Boolean result for deterministic matching evidence.
        errors:
          - Schema failures for invalid argument types.
          - Mismatched outputs from inconsistent runtime environments.
        usage_context:
          - Include in compliance traces and evidence bundles for policy decisions.
  std.string.starts_with:
    category: text_regex
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
    docs:
      - id: std.string.starts_with.doc.1.implementer
        summary: Check if a string begins with an exact prefix.
        audience: implementer
        status: active
        description: |-
          Purpose: Return true when the first argument starts with the second.
        inputs:
          - value: candidate text.
          - prefix: exact prefix string.
        returns:
          - Boolean true when prefix matches at position 0.
        errors:
          - Type validation for non-string arguments.
        usage_context:
          - Use where strict prefix routing is required.
      - id: std.string.starts_with.doc.1.operator
        summary: Route operational patterns based on stable prefix checks.
        audience: operator
        status: active
        description: |-
          Purpose: Prefix matching stays deterministic as long as input normalization
          is explicit and deterministic.
        inputs:
          - value: input text.
          - prefix: expected prefix.
        returns:
          - Boolean decision used for flow branching.
        errors:
          - Schema/runtime failures for invalid values.
        usage_context:
          - Use to classify status channels and event prefixes.
      - id: std.string.starts_with.doc.1.integrator
        summary: Build deterministic composition rules on prefix checks.
        audience: integrator
        status: active
        description: |-
          Purpose: Use this deterministic predicate when composing higher-order
          condition trees.
        inputs:
          - value: upstream message text.
          - prefix: deterministic prefix token.
        returns:
          - Boolean result.
        errors:
          - Non-string values are rejected with validation errors.
        usage_context:
          - Use in shared policies and reusable pipeline predicates.
      - id: std.string.starts_with.doc.1.maintainer
        summary: Track compatibility impact of prefix matching rules.
        audience: maintainer
        status: active
        description: |-
          Purpose: Maintain stable checks for routing and parser compatibility.
        inputs:
          - value: prefix source string.
          - prefix: expected leading token.
        returns:
          - Boolean.
        errors:
          - Validation failures when argument shape changes.
      - id: std.string.starts_with.doc.1.governance
        summary: Ensure governance decisions using prefix checks remain deterministic.
        audience: governance
        status: active
        description: |-
          Purpose: Provide reliable decision inputs for policy enforcement rules.
        inputs:
          - value: text under governance review.
          - prefix: policy token prefix.
        returns:
          - Boolean.
        errors:
          - Schema violations for argument type mismatches.
      - id: std.string.starts_with.doc.1.reviewer
        summary: Review complete prefix semantics and validation behavior.
        audience: reviewer
        status: active
        description: |-
          Purpose: Make prefix matching behavior easy to verify in spec-driven reviews.
        inputs:
          - value: candidate string.
          - prefix: expected starting substring.
        returns:
          - Boolean.
        errors:
          - Invalid input shape errors.
      - id: std.string.starts_with.doc.1.auditor
        summary: Record deterministic prefix checks for compliance trails.
        audience: auditor
        status: active
        description: |-
          Purpose: Make prefix checks inspectable in audit evidence.
        inputs:
          - value: reviewed text.
          - prefix: required prefix token.
        returns:
          - Boolean decision.
        errors:
          - Input validation failures and unexpected argument types.
  std.string.ends_with:
    category: text_regex
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
    docs:
      - id: std.string.ends_with.doc.1.implementer
        summary: Check whether a string ends with an exact suffix.
        audience: implementer
        status: active
        description: |-
          Purpose: Return true when the first argument has the second argument as
          its trailing suffix.
        inputs:
          - value: candidate text.
          - suffix: expected suffix string.
        returns:
          - Boolean true/false.
        errors:
          - Validation errors for non-string values.
        usage_context:
          - Use for extension checks and route partitioning.
      - id: std.string.ends_with.doc.1.operator
        summary: Use stable suffix checks for run-path decisions.
        audience: operator
        status: active
        description: |-
          Purpose: Provides deterministic suffix checks for operational classification.
        inputs:
          - value: source payload text.
          - suffix: deterministic suffix token.
        returns:
          - Boolean decision.
        errors:
          - Schema/runtime validation failures.
      - id: std.string.ends_with.doc.1.integrator
        summary: Compose deterministic suffix-based predicates in integrations.
        audience: integrator
        status: active
        description: |-
          Purpose: Use suffix checks consistently in service adapters and workflows.
        inputs:
          - value: upstream text.
          - suffix: expected trailing token.
        returns:
          - Boolean.
        errors:
          - Shape and type validation failures.
      - id: std.string.ends_with.doc.1.maintainer
        summary: Track suffix behavior across upgrades for stable integrations.
        audience: maintainer
        status: active
        description: |-
          Purpose: Confirm compatibility impact for suffix checks in deployed pipelines.
        inputs:
          - value: value string.
          - suffix: expected suffix.
        returns:
          - Boolean.
        errors:
          - Validation failures for incorrect arity or argument type.
      - id: std.string.ends_with.doc.1.governance
        summary: Ensure policy routing with suffix checks remains deterministic.
        audience: governance
        status: active
        description: |-
          Purpose: Keep suffix checks predictable for controls and gates.
        inputs:
          - value: governed text.
          - suffix: policy suffix token.
        returns:
          - Boolean.
        errors:
          - Schema failures for invalid arguments.
      - id: std.string.ends_with.doc.1.reviewer
        summary: Verify suffix behavior and failure modes.
        audience: reviewer
        status: active
        description: |-
          Purpose: Expose complete suffix semantics for review.
        inputs:
          - value: candidate string.
          - suffix: expected trailing token.
        returns:
          - Boolean.
        errors:
          - Validation failure when value or suffix missing.
      - id: std.string.ends_with.doc.1.auditor
        summary: Preserve deterministic evidence for suffix checks.
        audience: auditor
        status: active
        description: |-
          Purpose: Use deterministic suffix semantics in audit-oriented decision trails.
        inputs:
          - value: text under review.
          - suffix: expected trailing token.
        returns:
          - Boolean.
        errors:
          - Validation and runtime assertion failures.
  std.string.trim:
    category: text_regex
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.string.lower:
    category: text_regex
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.string.upper:
    category: text_regex
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.string.split:
    category: text_regex
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.string.join:
    category: text_regex
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.string.replace:
    category: text_regex
    arity: 3
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.string.pad_left:
    category: text_regex
    arity: 3
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.string.pad_right:
    category: text_regex
    arity: 3
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.string.regex_match:
    category: text_regex
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.string.matches:
    category: text_regex
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.string.matches_all:
    category: text_regex
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.len:
    category: sequence_collection
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.count:
    category: sequence_collection
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.first:
    category: sequence_collection
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.rest:
    category: sequence_collection
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.last:
    category: sequence_collection
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.nth:
    category: sequence_collection
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.take:
    category: sequence_collection
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.drop:
    category: sequence_collection
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.slice:
    category: sequence_collection
    arity: 3
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.append:
    category: sequence_collection
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.prepend:
    category: sequence_collection
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.concat:
    category: sequence_collection
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.reverse:
    category: sequence_collection
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.flatten:
    category: sequence_collection
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.math.range:
    category: sequence_collection
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.repeat:
    category: sequence_collection
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.map:
    category: sequence_collection
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.filter:
    category: sequence_collection
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.reject:
    category: sequence_collection
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.find:
    category: sequence_collection
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.reduce:
    category: sequence_collection
    arity: 3
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.partition:
    category: sequence_collection
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.group_by:
    category: sequence_collection
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.uniq_by:
    category: sequence_collection
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.distinct:
    category: sequence_collection
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.sort:
    category: sequence_collection
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.sort_by:
    category: sequence_collection
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.zip:
    category: sequence_collection
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.zip_with:
    category: sequence_collection
    arity: 3
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.object.pluck:
    category: sequence_collection
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.includes:
    category: sequence_collection
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.in:
    category: sequence_collection
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.contains_all:
    category: sequence_collection
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.collection.contains_any:
    category: sequence_collection
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.object.has_key:
    category: object_map
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.object.get:
    category: object_map
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.object.get_in:
    category: object_map
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.object.get_or:
    category: object_map
    arity: 3
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.object.has_path:
    category: object_map
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.object.keys:
    category: object_map
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.object.values:
    category: object_map
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.object.entries:
    category: object_map
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.object.assoc:
    category: object_map
    arity: 3
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.object.dissoc:
    category: object_map
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.object.merge:
    category: object_map
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.object.merge_deep:
    category: object_map
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.object.pick:
    category: object_map
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.object.omit:
    category: object_map
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.object.prop_eq:
    category: object_map
    arity: 3
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.object.where:
    category: object_map
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.object.keys_exact:
    category: object_map
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.object.keys_include:
    category: object_map
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.object.keys_exclude:
    category: object_map
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.set.union:
    category: set_algebra
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.set.intersection:
    category: set_algebra
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.set.difference:
    category: set_algebra
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.set.symmetric_difference:
    category: set_algebra
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.set.is_subset:
    category: set_algebra
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.set.is_superset:
    category: set_algebra
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.set.set_equals:
    category: set_algebra
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.json.parse:
    category: json_utilities
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.json.stringify:
    category: json_utilities
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.null.coalesce:
    category: null_default
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.null.default_to:
    category: null_default
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.fn.identity:
    category: functional_combinators
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.fn.always:
    category: functional_combinators
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.fn.compose:
    category: functional_combinators
    arity: 3
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.fn.pipe:
    category: functional_combinators
    arity: 3
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.schema.match:
    category: schema_shape
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  std.schema.errors:
    category: schema_shape
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.path.normalize:
    category: fs_path
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.path.join:
    category: fs_path
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.path.split:
    category: fs_path
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.path.dirname:
    category: fs_path
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.path.basename:
    category: fs_path
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.path.extname:
    category: fs_path
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.path.stem:
    category: fs_path
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.path.is_abs:
    category: fs_path
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.path.has_ext:
    category: fs_path
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.path.change_ext:
    category: fs_path
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.path.relativize:
    category: fs_path
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.path.common_prefix:
    category: fs_path
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.path.parents:
    category: fs_path
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.path.within:
    category: fs_path
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.path.compare:
    category: fs_path
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.path.sort:
    category: fs_path
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.file.exists:
    category: fs_file
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.file.is_file:
    category: fs_file
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.file.is_dir:
    category: fs_file
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.file.size_bytes:
    category: fs_file
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.file.path:
    category: fs_file
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.file.name:
    category: fs_file
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.file.parent:
    category: fs_file
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.file.ext:
    category: fs_file
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.file.get:
    category: fs_file
    arity: 3
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.walk:
    category: fs_file
    arity: 2
    pure: false
    deterministic: false
    error_class: runtime
    parity_required: true
  ops.fs.file.set:
    category: fs_file
    arity: 2
    pure: false
    deterministic: false
    error_class: runtime
    parity_required: true
  ops.fs.file.append:
    category: fs_file
    arity: 2
    pure: false
    deterministic: false
    error_class: runtime
    parity_required: true
  ops.fs.file.mkdir_p:
    category: fs_file
    arity: 1
    pure: false
    deterministic: false
    error_class: runtime
    parity_required: true
  ops.fs.file.remove:
    category: fs_file
    arity: 1
    pure: false
    deterministic: false
    error_class: runtime
    parity_required: true
  ops.fs.json.parse:
    category: fs_json
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.json.get:
    category: fs_json
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.json.get_or:
    category: fs_json
    arity: 3
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.json.has_path:
    category: fs_json
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.yaml.parse:
    category: fs_json
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.yaml.stringify:
    category: fs_json
    arity: 1
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.yaml.get:
    category: fs_json
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.yaml.get_or:
    category: fs_json
    arity: 3
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.yaml.has_path:
    category: fs_json
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.glob.match:
    category: fs_glob
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.glob.filter:
    category: fs_glob
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.glob.any:
    category: fs_glob
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.fs.glob.all:
    category: fs_glob
    arity: 2
    pure: true
    deterministic: true
    error_class: schema
    parity_required: true
  ops.os.exec:
    category: os_process
    arity: 2
    pure: false
    deterministic: false
    error_class: runtime
    parity_required: true
  ops.os.exec_capture:
    category: os_process
    arity: 2
    pure: false
    deterministic: false
    error_class: runtime
    parity_required: true
  ops.os.exec_capture_ex:
    category: os_process
    arity: 2
    pure: false
    deterministic: false
    error_class: runtime
    parity_required: true
  ops.os.env_get:
    category: os_process
    arity: 2
    pure: false
    deterministic: false
    error_class: runtime
    parity_required: true
  ops.os.env_has:
    category: os_process
    arity: 1
    pure: false
    deterministic: false
    error_class: runtime
    parity_required: true
  ops.os.cwd:
    category: os_process
    arity: 0
    pure: false
    deterministic: false
    error_class: runtime
    parity_required: true
  ops.os.pid:
    category: os_process
    arity: 0
    pure: false
    deterministic: false
    error_class: runtime
    parity_required: true
  ops.os.sleep_ms:
    category: os_process
    arity: 1
    pure: false
    deterministic: false
    error_class: runtime
    parity_required: true
  ops.os.exit_code:
    category: os_process
    arity: 0
    pure: false
    deterministic: false
    error_class: runtime
    parity_required: true
  ops.terminal.prompt:
    category: terminal_io
    arity: 2
    pure: false
    deterministic: false
    error_class: runtime
    parity_required: true
schema_shape_keys:
- type
- required
- properties
- allow_extra
- items
- min_items
- max_items
- min_length
- max_length
- pattern
- const
- enum
- all_of
- any_of
- not
behavior_defaults:
  pure: true
  deterministic: true
  parity_required: true
  error_classes:
  - schema
  - assertion
  - runtime
